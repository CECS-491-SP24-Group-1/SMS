// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package challenge

import (
	"fmt"
	"strings"
)

const (
	// The purpose of the challenge is unknown.
	CPurposeUNKNOWN CPurpose = iota
	// The purpose of the challenge is to complete account registration.
	CPurposeREGISTER
	// The purpose of the challenge is to perform account login.
	CPurposeLOGIN
	// The purpose of the challenge is to complete account deletion.
	CPurposeDELETE
	// The purpose of the challenge is to confirm a claimed identity.
	CPurposeCONFIRM
)

var ErrInvalidCPurpose = fmt.Errorf("not a valid CPurpose, try [%s]", strings.Join(_CPurposeNames, ", "))

const _CPurposeName = "UNKNOWNREGISTERLOGINDELETECONFIRM"

var _CPurposeNames = []string{
	_CPurposeName[0:7],
	_CPurposeName[7:15],
	_CPurposeName[15:20],
	_CPurposeName[20:26],
	_CPurposeName[26:33],
}

// CPurposeNames returns a list of possible string values of CPurpose.
func CPurposeNames() []string {
	tmp := make([]string, len(_CPurposeNames))
	copy(tmp, _CPurposeNames)
	return tmp
}

// CPurposeValues returns a list of the values for CPurpose
func CPurposeValues() []CPurpose {
	return []CPurpose{
		CPurposeUNKNOWN,
		CPurposeREGISTER,
		CPurposeLOGIN,
		CPurposeDELETE,
		CPurposeCONFIRM,
	}
}

var _CPurposeMap = map[CPurpose]string{
	CPurposeUNKNOWN:  _CPurposeName[0:7],
	CPurposeREGISTER: _CPurposeName[7:15],
	CPurposeLOGIN:    _CPurposeName[15:20],
	CPurposeDELETE:   _CPurposeName[20:26],
	CPurposeCONFIRM:  _CPurposeName[26:33],
}

// String implements the Stringer interface.
func (x CPurpose) String() string {
	if str, ok := _CPurposeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("CPurpose(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x CPurpose) IsValid() bool {
	_, ok := _CPurposeMap[x]
	return ok
}

var _CPurposeValue = map[string]CPurpose{
	_CPurposeName[0:7]:   CPurposeUNKNOWN,
	_CPurposeName[7:15]:  CPurposeREGISTER,
	_CPurposeName[15:20]: CPurposeLOGIN,
	_CPurposeName[20:26]: CPurposeDELETE,
	_CPurposeName[26:33]: CPurposeCONFIRM,
}

// ParseCPurpose attempts to convert a string to a CPurpose.
func ParseCPurpose(name string) (CPurpose, error) {
	if x, ok := _CPurposeValue[name]; ok {
		return x, nil
	}
	return CPurpose(0), fmt.Errorf("%s is %w", name, ErrInvalidCPurpose)
}

// MustParseCPurpose converts a string to a CPurpose, and panics if is not valid.
func MustParseCPurpose(name string) CPurpose {
	val, err := ParseCPurpose(name)
	if err != nil {
		panic(err)
	}
	return val
}

// MarshalText implements the text marshaller method.
func (x CPurpose) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *CPurpose) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseCPurpose(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
