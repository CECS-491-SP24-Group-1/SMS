// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package obj

import (
	"fmt"
	"strings"
)

const (
	// The token is valid nowhere.												(binary: 0000 0000)
	TokenScopeNONE TokenScope = iota
	// The token is only allowed to complete the login challenges.				(binary: 0000 0001)
	TokenScopePOSTSIGNUP
	// The token is allowed to be used everywhere that a normal user can access	(binary: 0000 0010)
	TokenScopeUSER
	// The token is valid anywhere.												(binary: 1111 1111)
	TokenScopeEVERWHERE TokenScope = iota + 252
)

var ErrInvalidTokenScope = fmt.Errorf("not a valid TokenScope, try [%s]", strings.Join(_TokenScopeNames, ", "))

const _TokenScopeName = "NONEPOST_SIGNUPUSEREVERWHERE"

var _TokenScopeNames = []string{
	_TokenScopeName[0:4],
	_TokenScopeName[4:15],
	_TokenScopeName[15:19],
	_TokenScopeName[19:28],
}

// TokenScopeNames returns a list of possible string values of TokenScope.
func TokenScopeNames() []string {
	tmp := make([]string, len(_TokenScopeNames))
	copy(tmp, _TokenScopeNames)
	return tmp
}

// TokenScopeValues returns a list of the values for TokenScope
func TokenScopeValues() []TokenScope {
	return []TokenScope{
		TokenScopeNONE,
		TokenScopePOSTSIGNUP,
		TokenScopeUSER,
		TokenScopeEVERWHERE,
	}
}

var _TokenScopeMap = map[TokenScope]string{
	TokenScopeNONE:       _TokenScopeName[0:4],
	TokenScopePOSTSIGNUP: _TokenScopeName[4:15],
	TokenScopeUSER:       _TokenScopeName[15:19],
	TokenScopeEVERWHERE:  _TokenScopeName[19:28],
}

// String implements the Stringer interface.
func (x TokenScope) String() string {
	if str, ok := _TokenScopeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("TokenScope(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TokenScope) IsValid() bool {
	_, ok := _TokenScopeMap[x]
	return ok
}

var _TokenScopeValue = map[string]TokenScope{
	_TokenScopeName[0:4]:   TokenScopeNONE,
	_TokenScopeName[4:15]:  TokenScopePOSTSIGNUP,
	_TokenScopeName[15:19]: TokenScopeUSER,
	_TokenScopeName[19:28]: TokenScopeEVERWHERE,
}

// ParseTokenScope attempts to convert a string to a TokenScope.
func ParseTokenScope(name string) (TokenScope, error) {
	if x, ok := _TokenScopeValue[name]; ok {
		return x, nil
	}
	return TokenScope(0), fmt.Errorf("%s is %w", name, ErrInvalidTokenScope)
}

// MustParseTokenScope converts a string to a TokenScope, and panics if is not valid.
func MustParseTokenScope(name string) TokenScope {
	val, err := ParseTokenScope(name)
	if err != nil {
		panic(err)
	}
	return val
}

// MarshalText implements the text marshaller method.
func (x TokenScope) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *TokenScope) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseTokenScope(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
